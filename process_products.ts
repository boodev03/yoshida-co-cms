import { parse } from "csv-parse/sync";
import * as fs from "fs";
import * as path from "path";

// --- TYPE DEFINITIONS (matching the database schema) ---

interface Category {
  id: number;
  type: "cases";
}

interface CategoryTranslation {
  category_id: number;
  language_code: "ja" | "en";
  category_name: string;
}

interface Post {
  id: number;
  type: "cases";
  category: string; // Comma-separated list of category names
  thumbnail: string;
}

interface ContentSection {
  type: "html";
  content: string;
}

interface PostTranslation {
  post_id: number;
  language_code: "ja" | "en";
  title: string;
  cardDescription: string;
  sections: ContentSection[];
}

// --- CSV ROW INTERFACE ---

interface CsvRow {
  ID: string;
  Title: string;
  Content: string;
  Excerpt: string;
  "Post Type": string;
  "Image URL": string;
  製品紹介カテゴリー: string;
  _locale: string;
  _original_post: string;
  Status: string;
}

// --- UTILITY FUNCTIONS ---

/**
 * Escapes a string for use in an SQL single-quoted literal.
 * @param value The string to escape.
 * @returns The escaped string.
 */
const escapeSqlString = (value: string): string => {
  if (value === null || value === undefined) {
    return "NULL";
  }
  return `'${value.replace(/'/g, "''")}'`;
};

/**
 * Extracts the first image URL from the pipe-separated string.
 * @param imageUrlField The 'Image URL' field from the CSV.
 * @returns The first URL or an empty string.
 */
const getThumbnailUrl = (imageUrlField: string): string => {
  if (!imageUrlField) return "";
  return imageUrlField.split("|")[0] || "";
};

/**
 * Creates a short description from the main content.
 * @param content The HTML content string.
 * @returns A truncated plain text string.
 */
const createCardDescription = (content: string): string => {
  // Remove HTML tags and extra whitespace, then truncate.
  const plainText = content
    .replace(/<[^>]*>/g, " ")
    .replace(/\s+/g, " ")
    .trim();
  return plainText.length > 150
    ? plainText.substring(0, 147) + "..."
    : plainText;
};

// --- MAIN LOGIC ---

/**
 * Main function to process the CSV and generate the SQL file.
 */
const generateSqlScript = () => {
  const csvFilePath = path.join(__dirname, "製品紹介_all.csv");
  if (!fs.existsSync(csvFilePath)) {
    console.error(`Error: The file ${csvFilePath} was not found.`);
    return;
  }
  const fileContent = fs.readFileSync(csvFilePath, { encoding: "utf-8" });

  // Parse the CSV content
  const records: CsvRow[] = parse(fileContent, {
    columns: true,
    skip_empty_lines: true,
  });

  // Filter for relevant posts (published products)
  const publishedPosts = records.filter(
    (row) => row.Status === "publish" && row["Post Type"] === "product"
  );

  const japanesePosts = publishedPosts.filter((row) => row._locale === "ja");
  const englishPostsMap = new Map<string, CsvRow>(
    publishedPosts
      .filter((row) => row._locale === "en_US" && row._original_post)
      .map((row) => [row._original_post, row])
  );

  const sqlStatements: string[] = [];
  sqlStatements.push("-- Generated by TypeScript Script\n");
  sqlStatements.push("-- Languages table pre-populated as per schema");
  sqlStatements.push(
    "INSERT OR IGNORE INTO languages (code, name, is_default) VALUES ('en', 'English', FALSE), ('ja', 'Japanese', TRUE);\n"
  );

  // 1. Process Categories
  console.log("Processing categories...");
  const uniqueCategories = new Set<string>();
  japanesePosts.forEach((row) => {
    row.製品紹介カテゴリー.split("|").forEach((cat) => {
      if (cat) uniqueCategories.add(cat.trim());
    });
  });

  const categoryMap = new Map<string, number>();
  let categoryIdCounter = 1;

  sqlStatements.push("-- Inserting Categories");
  for (const catName of uniqueCategories) {
    const categoryId = categoryIdCounter++;
    categoryMap.set(catName, categoryId);

    const category: Category = { id: categoryId, type: "cases" };
    sqlStatements.push(
      `INSERT INTO categories (id, type) VALUES (${
        category.id
      }, ${escapeSqlString(category.type)});`
    );

    // Add Japanese translation for the category
    const catTranslation: CategoryTranslation = {
      category_id: categoryId,
      language_code: "ja",
      category_name: catName,
    };
    sqlStatements.push(
      `INSERT INTO category_translations (category_id, language_code, category_name) VALUES (${
        catTranslation.category_id
      }, ${escapeSqlString(catTranslation.language_code)}, ${escapeSqlString(
        catTranslation.category_name
      )});`
    );
    // NOTE: English category names are not in the CSV, so we only insert Japanese.
  }
  sqlStatements.push("\n-- End of Categories\n");

  // 2. Process Posts and Translations
  console.log("Processing posts and translations...");
  sqlStatements.push("-- Inserting Posts and Post Translations");
  for (const jaPost of japanesePosts) {
    const postId = parseInt(jaPost.ID, 10);
    if (isNaN(postId)) continue;

    // Create the main post entry
    const post: Post = {
      id: postId,
      type: "cases",
      category: jaPost.製品紹介カテゴリー
        .split("|")
        .filter((c) => c)
        .join(","),
      thumbnail: getThumbnailUrl(jaPost["Image URL"]),
    };
    sqlStatements.push(
      `INSERT INTO posts (id, type, category, thumbnail) VALUES (${
        post.id
      }, ${escapeSqlString(post.type)}, ${escapeSqlString(
        post.category
      )}, ${escapeSqlString(post.thumbnail)});`
    );

    // Create Japanese translation
    const jaTranslation: PostTranslation = {
      post_id: postId,
      language_code: "ja",
      title: jaPost.Title,
      cardDescription: createCardDescription(jaPost.Content),
      sections: [{ type: "html", content: jaPost.Content }],
    };
    sqlStatements.push(
      `INSERT INTO post_translations (post_id, language_code, title, cardDescription, sections) VALUES (${
        jaTranslation.post_id
      }, ${escapeSqlString(jaTranslation.language_code)}, ${escapeSqlString(
        jaTranslation.title
      )}, ${escapeSqlString(jaTranslation.cardDescription)}, ${escapeSqlString(
        JSON.stringify(jaTranslation.sections)
      )});`
    );

    // Check for and create English translation
    const enPost = englishPostsMap.get(jaPost.ID);
    if (enPost) {
      const enTranslation: PostTranslation = {
        post_id: postId, // Linked to the same Japanese post ID
        language_code: "en",
        title: enPost.Title,
        cardDescription: createCardDescription(enPost.Content),
        sections: [{ type: "html", content: enPost.Content }],
      };
      sqlStatements.push(
        `INSERT INTO post_translations (post_id, language_code, title, cardDescription, sections) VALUES (${
          enTranslation.post_id
        }, ${escapeSqlString(enTranslation.language_code)}, ${escapeSqlString(
          enTranslation.title
        )}, ${escapeSqlString(
          enTranslation.cardDescription
        )}, ${escapeSqlString(JSON.stringify(enTranslation.sections))});\n`
      );
    } else {
      sqlStatements.push("\n"); // Add a newline for readability even if no English post
    }
  }
  sqlStatements.push("\n-- End of Posts\n");

  // 3. Write to SQL file
  const outputFilePath = path.join(__dirname, "insert_cases.sql");
  fs.writeFileSync(outputFilePath, sqlStatements.join("\n"));

  console.log(`Successfully generated SQL script at: ${outputFilePath}`);
};

// Execute the script
generateSqlScript();
